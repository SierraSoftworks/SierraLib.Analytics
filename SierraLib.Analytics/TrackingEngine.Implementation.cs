using Akavache;
using RestSharp;
using SierraLib.Analytics.Implementation;
using System.Collections.Generic;
using System.Reactive.Linq;
using System.Threading.Tasks;

namespace SierraLib.Analytics
{
    public abstract partial class TrackingEngine
    {

        #region Network

        private IRestClient _restClient = null;
        /// <summary>
        /// Gets the <see cref="IRestClient"/> used to send requests
        /// to the tracking server.
        /// </summary>
        protected IRestClient NetworkClient
        {
            get
            {
                if (_restClient == null)
                {
                    _restClient = CreateNetworkClient(UserAgent);
                }

                return _restClient;
            }
        }

        /// <summary>
        /// Creates a <see cref="IRestClient"/> which will be used
        /// by the <see cref="TrackingManager"/> for tracking packet
        /// submissions.
        /// </summary>
        /// <param name="userAgent">The default UserAgent string to use for the client</param>
        /// <returns>
        /// Returns a <see cref="IRestClient"/> configured for sending
        /// tracking data for this <see cref="TrackingEngine"/> instance.
        /// </returns>
        protected abstract IRestClient CreateNetworkClient(string userAgent);

        /// <summary>
        /// Requests that a new <see cref="NetworkClient"/> is created for this
        /// engine, allowing changes to be made to the client used by subsequent requests.
        /// </summary>
        protected void RequestNewClient()
        {
            _restClient = null;
        }

        #endregion

        #region Request Preperation

        /// <summary>
        /// Creates a <see cref="IRestRequest"/> for the given application context
        /// which will be used to generate the tracking request for the engine.
        /// </summary>
        /// <param name="application">The application context which generated the tracking request</param>
        /// <returns></returns>
        protected abstract Task<IRestRequest> CreateRequestAsync(ITrackingApplication application);

        /// <summary>
        /// Allows the engine to pre-process a tracking request before it is handed
        /// off to the <see cref="ITrackingModule"/>s for population.
        /// </summary>
        /// <param name="request">The request being used for the current tracking hit</param>
        protected async virtual Task PreProcessAsync(IRestRequest request)
        {
            await Task.Yield();
        }

        /// <summary>
        /// Allows the engine to post-process a tracking request after it has been
        /// populated by all <see cref="ITrackingModule"/>s.
        /// </summary>
        /// <param name="request">The request being used for the current tracking hit</param>
		protected async virtual Task PostProcessAsync(IRestRequest request)
        {
            await Task.Yield();
        }

        /// <summary>
        /// Generates the <see cref="PreparedTrackingRequest"/> object which represents
        /// a tracking request which is ready for queuing.
        /// </summary>
        /// <param name="request">The populated and post-processed request waiting to be sent</param>
        /// <param name="finalizationQueue">A number of modules which require the ability to finalize a request prior to transmission</param>
        /// <returns>Returns a <see cref="PreparedTrackingRequest"/> object tailored to the engine's specific requirements</returns>
		protected abstract Task<PreparedTrackingRequest> PrepareRequestAsync(IRestRequest request, IEnumerable<ITrackingFinalize> finalizationQueue);

        #endregion

        #region Client Identification

        /// <summary>
        /// Gets a unique identifier for this tracker instance - determined by the account it
        /// submits its data to.
        /// </summary>
        /// <returns></returns>
        /// <remarks>
        /// This is used to link disk queued tracking requests to their respective engines.
        /// </remarks>
        protected abstract string GetTrackerID();

        /// <summary>
        /// Gets a unique identifier for the current user
        /// </summary>
        /// <param name="application">The application for which the client ID should be retrieved</param>
        /// <returns>Returns the unique identifier representing the currently active user</returns>
        /// <remarks>
        /// Each client ID is unique to a computer, user account, <see cref="ITrackingApplication"/>, <see cref="TrackingEngine"/> and
        /// tracker ID given by <see cref="GetTrackerID()"/> (provided that the <see cref="CreateNewClientID"/> function returns
        /// unique values).
        /// 
        /// If a client ID is not found for the current combination of the above then one will be generated by making a call to
        /// <see cref="CreateNewClientID"/>.
        /// </remarks>
        protected async Task<string> GetClientIDAsync(ITrackingApplication application)
        {
            var clientIDKey = string.Format("{0}:{1}:{2}", this.GetType().FullName, application.Name, GetTrackerID());
            return await KeyStore.GetOrFetchObject<string>(clientIDKey, () => CreateNewClientIDAsync(application)).FirstAsync();
        }

        protected abstract Task<string> CreateNewClientIDAsync(ITrackingApplication application);

        #endregion
    }
}
